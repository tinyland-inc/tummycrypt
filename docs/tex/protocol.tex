\documentclass[11pt,a4paper]{article}
\input{preamble}

\fancyhead[L]{\small\textsc{tcfs}}
\fancyhead[R]{\small Protocol Specification}

\title{tcfs Protocol Specification}
\author{tcfs / TummyCrypt}
\date{February 2026}

\begin{document}
\maketitle
\tableofcontents
\newpage

% ─────────────────────────────────────────────────────────────────────────────
\section{Stub File Formats}

\tcfs{} uses lightweight stub files to represent remote content locally.
Stubs are small metadata files that trigger on-demand hydration when accessed.

\subsection{\code{.tc} File Stub}

A \code{.tc} stub replaces a single file (e.g., \code{photo.jpg} becomes
\code{photo.jpg.tc}). The stub is a JSON file containing the metadata needed
to reconstruct the original file.

\begin{lstlisting}[language=json]
{
  "version": 1,
  "file_id": "<BLAKE3 hash of original file, hex>",
  "original_name": "photo.jpg",
  "original_size": 4194304,
  "mime_type": "image/jpeg",
  "modified_at": "2026-02-20T12:00:00Z",
  "chunk_count": 3,
  "manifest_key": "chunks/manifests/<file_id>",
  "remote_prefix": "tcfs/default"
}
\end{lstlisting}

\begin{longtable}{lll}
  \toprule
  \textbf{Field} & \textbf{Type} & \textbf{Description} \\
  \midrule
  \endhead
  \code{version}       & u32    & Stub format version (currently 1) \\
  \code{file\_id}      & string & BLAKE3 hash of the original file content \\
  \code{original\_name}& string & Original filename without \code{.tc} extension \\
  \code{original\_size}& u64    & Original file size in bytes \\
  \code{mime\_type}    & string & MIME type (optional, for display hints) \\
  \code{modified\_at}  & string & ISO 8601 timestamp of last modification \\
  \code{chunk\_count}  & u32    & Number of chunks in the manifest \\
  \code{manifest\_key} & string & S3 key path to the chunk manifest \\
  \code{remote\_prefix}& string & S3 prefix where chunks are stored \\
  \bottomrule
\end{longtable}

\subsection{\code{.tcf} Folder Stub}

A \code{.tcf} stub represents an unsynced directory. It is a JSON file listing
the directory's remote contents without downloading them.

\begin{lstlisting}[language=json]
{
  "version": 1,
  "dir_id": "<BLAKE3 hash of directory listing>",
  "original_name": "photos",
  "entry_count": 47,
  "total_size": 1073741824,
  "remote_prefix": "tcfs/default/photos"
}
\end{lstlisting}

% ─────────────────────────────────────────────────────────────────────────────
\section{Chunk Layout (S3/SeaweedFS)}

Content-addressed storage using BLAKE3 hashes as keys:

\begin{lstlisting}
{prefix}/
  chunks/
    {blake3_hash_1}     # Compressed+encrypted chunk
    {blake3_hash_2}
    ...
  manifests/
    {file_blake3_hash}  # Chunk manifest (JSON)
\end{lstlisting}

\subsection{Chunk Manifest Format}

\begin{lstlisting}[language=json]
{
  "version": 1,
  "file_hash": "<BLAKE3 hex of original file>",
  "file_size": 4194304,
  "chunk_count": 3,
  "chunks": [
    {
      "hash": "<BLAKE3 hex of chunk ciphertext>",
      "offset": 0,
      "length": 1398101,
      "compressed_length": 1205432
    }
  ]
}
\end{lstlisting}

Each chunk entry records the BLAKE3 hash of the \emph{ciphertext} (used as the
CAS key in S3), the byte offset and length within the original file, and the
compressed length of the stored chunk.

% ─────────────────────────────────────────────────────────────────────────────
\section{Chunking Algorithm}

\tcfs{} uses \textbf{FastCDC} (Fast Content-Defined Chunking) for splitting
files into variable-size chunks:

\begin{longtable}{ll}
  \toprule
  \textbf{Parameter} & \textbf{Value} \\
  \midrule
  Minimum chunk size & 2\,KiB \\
  Average chunk size & 8\,KiB \\
  Maximum chunk size & 16\,KiB \\
  Hash function      & BLAKE3 \\
  Compression        & zstd (level 3) \\
  \bottomrule
\end{longtable}

Content-defined chunking ensures that inserting or modifying bytes in a file
only affects the chunks near the edit point. Unmodified regions produce
identical chunks, enabling efficient delta sync and deduplication.

% ─────────────────────────────────────────────────────────────────────────────
\section{Hydration Flow}

When a FUSE-mounted \code{.tc} stub is opened:

\begin{enumerate}
  \item FUSE \code{open()} intercepts the request.
  \item Manifest is fetched from \filepath{\{prefix\}/manifests/\{file\_hash\}}.
  \item Chunks are fetched in parallel from
        \filepath{\{prefix\}/chunks/\{chunk\_hash\}}.
  \item Each chunk is decompressed (zstd) and decrypted (XChaCha20-Poly1305).
  \item BLAKE3 hash of the reassembled file is verified against \code{file\_hash}.
  \item The file is served to the calling process via FUSE \code{read()}.
\end{enumerate}

% ─────────────────────────────────────────────────────────────────────────────
\section{State Tracking}

The sync engine maintains a local state cache (JSON file, migrating to RocksDB)
tracking per-file metadata:

\begin{itemize}
  \item Local path, remote S3 key, BLAKE3 hash, size
  \item Sync states: \code{synced}, \code{modified}, \code{pending\_upload},
        \code{pending\_download}, \code{conflict}
\end{itemize}

% ─────────────────────────────────────────────────────────────────────────────
\section{Wire Protocol (gRPC)}

The daemon (\tcfsd{}) exposes a gRPC service over a Unix domain socket:

\begin{lstlisting}[language=protobuf]
service TcfsDaemon {
  rpc Status(StatusRequest) returns (StatusResponse);
  rpc Mount(MountRequest) returns (MountResponse);
  rpc Unmount(UnmountRequest) returns (UnmountResponse);
  rpc Push(stream PushChunk) returns (stream PushProgress);
  rpc Pull(PullRequest) returns (stream PullProgress);
  rpc Hydrate(HydrateRequest) returns (stream HydrateProgress);
  rpc Unsync(UnsyncRequest) returns (UnsyncResponse);
  rpc SyncStatus(SyncStatusRequest) returns (SyncStatusResponse);
  rpc Watch(WatchRequest) returns (stream WatchEvent);
  rpc CredentialStatus(Empty) returns (CredentialStatusResponse);
  rpc ResolveConflict(ResolveConflictRequest)
      returns (ResolveConflictResponse);
}
\end{lstlisting}

See \filepath{crates/tcfs-core/proto/tcfs.proto} for the full service definition
including all message types.

\end{document}
